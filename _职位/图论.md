* 广度搜索优先：
* 经典走迷宫：(起点到终点)
```c++
  #include<bits/stdc++.h>
using namespace std;
char maze[100][100];
int book[100][100];
int dir[4][2] = {{0,1},{1,0},{0,-1},{-1,0}};//上下左右四个坐标 走向
int n, m; 

//坐标存储进入队列，步数也存入 
bool stayin(int tx, int ty) {
	return x>=0&&x<n&&y>=0&&y<m;
}
struct position
{
	int x, y, step;
	position(int px, int py, int pstep): x(px), y(py), step(pstep){ }
}

int bfs(int sx, int sy) {
	queue<position> que;//存储 
	q.push(position(sx, sy, 0));//起点入队
	book[sx][sy] = 1;
	//开始每个出入队，遍历所有结点 
	while(!que.empty()) {
		int x = que.front().x;//获取当前坐标与步数 
		int y = que.front().y;
		int step = que.front().step;
		que.pop();
		//开始四个方向走一波 
		for(int i = 0; i < 4; i++) {
			int tx = x + dir[i][0];
			int ty = y + dir[i][1];
			//越界，非障碍，未走过 
			if(stayin(tx,ty)&&maze[tx][ty]!='#'&&!book[tx][ty]) {
				if(maze[tx][ty] == 'T') {
					return step+1;
				}
				//如果上面外if都满足，且不是终点
				q.push(position(tx, ty, step+1));
				book[tx][ty] =1;
			}
		} 
	}
	return -1;//遍历所有，都到不了终点 
	
}
int main() {
	int sx sy;
	cin>>n>>m;
	for(int i = 0; i < n; i++) {
		//cin>>maze[i];//也可，行的列，当作string输入 
		for(int j = 0; j < m; j++) {
			cin>>maze[i][j];
			if(maze[i][j] == 'S') {
				sx = i;
				sy = j;
			}
			
		}
	}
	cout<<bfs(sx,sy);//输出步数 
} 
```
