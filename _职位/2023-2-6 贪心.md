**（本节只有思路，没有代码，思路中只有关键思路，有些步骤会省略，例如排序等，除了一些可能会用到的未学的知识代码外）**
* 贪心的本质是选择每一阶段的局部最优，从而达到全局最优。
* (有些需数学推导，举反例来猜想是不是贪心。没有固定解法，全靠惟手熟尔。想清楚局部最优，想清楚全局最优，感觉局部最优是可以推出全局最优，并想不出反例，那么就试一试贪心)
---
> 题一：455.分发饼干：https://leetcode.cn/problems/assign-cookies/
>>* 思路一：大饼干喂饱大胃口，胃口外循环，饼干if判断内自减（双指针思想遍历）
>>* 思路二：小饼干喂饱小胃口，饼干外循环，胃口if判断内自增（双指针思想遍历）

> 题二：376.摆动序列：https://leetcode.cn/problems/wiggle-subsequence/
>>* 思路一：考虑每一个局部峰值，一个峰值代表一个长度，删除单调性多节点的坡线得到更多峰值，从而拉长长度，分①上下坡有平坡；②数组首尾两端不特判（比如2为长度的数组，两个元素，可归并为第一种情况的情况，所以，长度起始可以设为1而不是0）；③单调坡度有平坡，可能会多统计一个峰值
>>* 思路二：（动态规划dp）

> 题三：最大子序和：https://leetcode.cn/problems/maximum-subarray/
>>* 思路一：负数会拉低和，所以连续和变小或者小于0时（正数），重置连续和起始位置（sum=0，重新初始化），再继续循环，每次循环时要判断当前连续和是否大于之前，大于就更新保存。（对于负数，一样的，小于零无所谓，一般都是重置），为包含全负数情况令记录变量值初始化为：INT32_MIN;//int 最小。
>>* 思路二：（动态规划dp）

>题四：买卖股票的最佳时机II:https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/
>>* sl:最终利润是可以分解的.局部最优：收集每天的正利润，全局最优：求得最大利润
>>* dp：

>题五：跳跃游戏I：https://leetcode.cn/problems/jump-game/
>>* sl:每次取每个点的最大覆盖范围，检查在覆盖范围内是否能走到终点。在范围内不必管如何走，只要看能否走到终点。局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点

>题六：跳跃游戏II：https://leetcode.cn/problems/jump-game-ii/
>>* sl:每次取每个点的最大范围，检查当前最大范围与下一步位置最大范围覆盖区域能否到达终点，不能则步数再加。

>题七：K次取反后最大化的数组和：https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/
>>* sl:贪心1：反转绝对值大的数，局部最优：让绝对值大的负数变为正数，当前数值达到最大，整体最优：整个数组和达到最大。贪心2：反转值小的自然数。局部最优：只找数值最小的正整数进行反转，当前数值和可以达到最大

>题八：加油站：https://leetcode.cn/problems/gas-station/
>>* 暴力模拟：
>>* sl：总油量大于等于总耗油量则说明有解，则计算每点的耗油量，连续耗油量大于连续得油量则更新起始下标，最后循环完得出总油量更大，则返回循环最后更新的下标，否则返回false。只要总油量更大，必有一个解，因为连续负的情况下总有一个很大的得油点可以解决其他点的问题。
>>* 全局模拟：代码：
```c++
int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int curSum = 0;
        int min = INT_MAX; // 从起点出发，油箱里的油量最小值
        for (int i = 0; i < gas.size(); i++) {
            int rest = gas[i] - cost[i];
            curSum += rest;
            if (curSum < min) {
                min = curSum;
            }
        }
        if (curSum < 0) return -1;  // 情况1,gas的总和小于cost总和
        if (min >= 0) return 0;     // 情况2,rest[i] = gas[i]-cost[i]为一天剩下的油，i从0开始计算累加到最后一站，如果累加没有出现负数，说明从0出发，油就没有断过，那么0就是起点
                                    // 情况3,如果累加的最小值是负数，汽车就要从非0节点出发，从后向前，看哪个节点能这个负数填平，能把这个负数填平的节点就是出发节点
        for (int i = gas.size() - 1; i >= 0; i--) {
            int rest = gas[i] - cost[i];
            min += rest;//从最后往前，一个个加，加到能使这些负数抵消的位置，则此为起点，足以抵消之后的连续负数.
            if (min >= 0) {
                return i;
            }
        }
        return -1;
```
