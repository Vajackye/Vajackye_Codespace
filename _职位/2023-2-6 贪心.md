**（本节只有思路，没有代码，思路中只有关键思路，有些步骤会省略，例如排序等，除了一些可能会用到的未学的知识代码外）**
* 贪心的本质是选择每一阶段的局部最优，从而达到全局最优。
* **没有技巧，全是熟练度，灵感，严格数学证明还得是学数学**
* **刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心，至于严格的数学证明，就不在讨论范围内**
---
> 题一：455.分发饼干：https://leetcode.cn/problems/assign-cookies/
>>* 思路一：大饼干喂饱大胃口，胃口外循环，饼干if判断内自减（双指针思想遍历）
>>* 思路二：小饼干喂饱小胃口，饼干外循环，胃口if判断内自增（双指针思想遍历）

> 题二：376.摆动序列：https://leetcode.cn/problems/wiggle-subsequence/
>>* 思路一：考虑每一个局部峰值，一个峰值代表一个长度，删除单调性多节点的坡线得到更多峰值，从而拉长长度，分①上下坡有平坡；②数组首尾两端不特判（比如2为长度的数组，两个元素，可归并为第一种情况的情况，所以，长度起始可以设为1而不是0）；③单调坡度有平坡，可能会多统计一个峰值
>>* 思路二：（动态规划dp）

> 题三：最大子序和：https://leetcode.cn/problems/maximum-subarray/
>>* 思路一：负数会拉低和，所以连续和变小或者小于0时（正数），重置连续和起始位置（sum=0，重新初始化），再继续循环，每次循环时要判断当前连续和是否大于之前，大于就更新保存。（对于负数，一样的，小于零无所谓，一般都是重置），为包含全负数情况令记录变量值初始化为：INT32_MIN;//int 最小。
>>* 思路二：（动态规划dp）

>题四：买卖股票的最佳时机II:https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/
>>* sl:最终利润是可以分解的.局部最优：收集每天的正利润，全局最优：求得最大利润
>>* dp：

>题五：跳跃游戏I：https://leetcode.cn/problems/jump-game/
>>* sl:每次取每个点的最大覆盖范围，检查在覆盖范围内是否能走到终点。在范围内不必管如何走，只要看能否走到终点。局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点

>题六：跳跃游戏II：https://leetcode.cn/problems/jump-game-ii/
>>* sl:每次取每个点的最大范围，检查当前最大范围与下一步位置最大范围覆盖区域能否到达终点，不能则步数再加。

>题七：K次取反后最大化的数组和：https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/
>>* sl:贪心1：反转绝对值大的数，局部最优：让绝对值大的负数变为正数，当前数值达到最大，整体最优：整个数组和达到最大。贪心2：反转值小的自然数。局部最优：只找数值最小的正整数进行反转，当前数值和可以达到最大

>题八：加油站：https://leetcode.cn/problems/gas-station/
>>* 暴力模拟：https://www.programmercarl.com/0134.%E5%8A%A0%E6%B2%B9%E7%AB%99.html#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E6%96%B9%E6%B3%95%E4%B8%80
>>* sl：总油量大于等于总耗油量则说明有解，则计算每点的耗油量，连续耗油量大于连续得油量则更新起始下标，最后循环完得出总油量更大，则返回循环最后更新的下标，否则返回false。只要总油量更大，必有一个解，因为连续负的情况下总有一个很大的得油点可以解决其他点的问题。
>>* 全局模拟：代码：
```c++
int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int curSum = 0;
        int min = INT_MAX; // 从起点出发，油箱里的油量最小值
        for (int i = 0; i < gas.size(); i++) {
            int rest = gas[i] - cost[i];
            curSum += rest;
            if (curSum < min) {
                min = curSum;
            }
        }
        if (curSum < 0) return -1;  // 情况1,gas的总和小于cost总和
        if (min >= 0) return 0;     // 情况2,rest[i] = gas[i]-cost[i]为一天剩下的油，i从0开始计算累加到最后一站，如果累加没有出现负数，说明从0出发，油就没有断过，那么0就是起点
                                    // 情况3,如果累加的最小值是负数，汽车就要从非0节点出发，从后向前，看哪个节点能这个负数填平，能把这个负数填平的节点就是出发节点
        for (int i = gas.size() - 1; i >= 0; i--) {
            int rest = gas[i] - cost[i];
            min += rest;//从最后往前，一个个加，加到能使这些负数抵消的位置，则此为起点，足以抵消之后的连续负数.
            if (min >= 0) {
                return i;
            }
        }
        return -1;
```

>题九（难）：分发糖果：https://leetcode.cn/problems/candy/
>>* 向后遍历（右大于左），向前遍历（左大于右），两次贪心，取两次遍历的获得糖果中最值，确保高分孩子的糖果比两边都高，且老师花销糖果最少，至于为什么两次遍历方向不一样，原因是，要利用前一次遍历的结果，进行比较，取糖果最大值，全局最优：分高比左右俩都多，图解如下：![1675756889581](https://user-images.githubusercontent.com/121871885/217186280-527a1f48-60a4-4838-b018-0d45390c3804.jpg)

>题十：柠檬水找零：https://leetcode.cn/problems/lemonade-change/
>>* 三种情况：5元拿下，10元返5，20优先反5+10，无10则5+5+5.局部最优：优先消耗10。全局最优：完成账单找零。f分类讨论即可，灵活运用if，else if先后顺序判断。

>题十一：根据身高重建队列：https://leetcode.cn/problems/queue-reconstruction-by-height/
>>* 跟题九一样，有两个维度，遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。先身高排序，同身高k小往后，先k排序没卵用。局部最优：然后按身高高的k小的先插入，身高低的在插入。因为身高低的插入时不会影响身高高的k.全局最优：最后都做完插入操作，整个队列满足题目队列属性。
