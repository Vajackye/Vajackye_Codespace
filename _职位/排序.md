### 堆排序
* 堆：
* 大顶堆，小顶堆
* 堆的实现（完全二叉树）：

* （大顶堆版：）
* ①建堆（数组）（第i个父节点->2i+1,2i+2为其子节点）；
* ②从最后一个**非**叶子节点开始，即最后一个父节点，开始与叶结点比较大小，从左到右比较，大则交换；
* ③下一个父节点...一直到根节点，往复此比较操作，如果该父节点与其叶子节点交换后，叶子节点也需要判断其（叶子的叶子）叶子结点是否满足大顶堆堆结构，不满足，交换。
* 参考网站：https://blog.csdn.net/lzuacm/article/details/52853194
* 实现代码如下：
```c++
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;

void adjust(int arr[], int len, int index)//数组（二叉），个数， 父节点索引
{
    int left = 2*index + 1;//父节点的叶子节点
    int right = 2*index + 2;//父节点的叶子节点
    int maxIdx = index;//父节点的索引
    if(left<len && arr[left] > arr[maxIdx]) maxIdx = left;//与左子节点比较，交换索引（因为还要比较右子节点）
    if(right<len && arr[right] > arr[maxIdx]) maxIdx = right;  // maxIdx是3个数中最大数的下标
    if(maxIdx != index)                 // 如果maxIdx的值有更新，若max无更新则，该父节点满足大顶堆结构
    {
        swap(arr[maxIdx], arr[index]);
        adjust(arr, len, maxIdx);       // 递归调整其他不满足堆性质的部分，再次进行叶子节点的叶子节点判断
    }

}
void heapSort(int arr[], int size)
{
    for(int i=size/2 - 1; i >= 0; i--)  // 对每一个非叶结点进行堆调整(从最后一个非叶结点开始)
    {
        adjust(arr, size, i);
    }
    for(int i = size - 1; i >= 1; i--)
    {
        swap(arr[0], arr[i]);           // 将当前最大的放置到数组末尾
        adjust(arr, i, 0);              // 将未完成排序的部分继续进行堆排序，可以对未与父节点交换的叶子节点，不满足堆结构，则继续交换操作
    }
}

int main()
{
    int array[8] = {8, 1, 14, 3, 21, 5, 7, 10};
    heapSort(array, 8);
    for(auto it: array)
    {
        cout<<it<<endl;
    }
    return 0;
}
```


### 基数排序
* 
### 归并排序
### 计数排序
### 希尔排序
