### 并查集
* https://blog.csdn.net/the_zed/article/details/105126583

* 并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题（即所谓的并、查）。比如说，我们可以用并查集来判断一个森林中有几棵树、某个节点是否属于某棵树等.

* 并查集主要由一个整型数组`pre[ ]`和两个函数`find( )`、`join( )`构成。数组 `pre[]` 记录了每个点的前驱节点是谁，函数 `find(x)` 用于查找指定节点 x 属于哪个集合，函数 `join(x,y)` 用于合并两个节点 x 和 y 。

* 其join()和find()函数实现：
```c++
  int find(int x)					//查找x的教主
{
	while(pre[x] != x)			//如果x的上级不是自己（则说明找到的人不是教主）
		x = pre[x];				//x继续找他的上级，直到找到教主为止
	return x;					//教主驾到~~~
}

void join(int x,int y)                     //我想让虚竹和周芷若做朋友
{
    int fx=find(x), fy=find(y);            //虚竹的老大是玄慈，芷若MM的老大是灭绝
    if(fx != fy)                           //玄慈和灭绝显然不是同一个人
        pre[fx]=fy;                        //方丈只好委委屈屈地当了师太的手下啦
}
```

* 路径压缩一（优化find）
* 即令所有间接上级直接挂钩于根节点（避免路径太长）。
```c++
  int find(int x)     				//查找结点 x的根结点 
{
    if(pre[x] == x) return x;		//递归出口：x的上级为 x本身，即 x为根结点        
    return pre[x] = find(pre[x]);	//此代码相当于先找到根结点 rootx，然后pre[x]=rootx 
}

```
* 该算法存在一个缺陷：只有当查找了某个节点的代表元（教主）后，才能对该查找路径上的各节点进行路径压缩。换言之，第一次执行查找操作的时候是实现没有压缩效果的，只有在之后才有效

* 路径压缩二（加权标记法）
* 加权标记法需要将树中所有节点都增设一个权值，用以表示该节点所在树中的高度（比如用`rank[x]=3`表示 x 节点所在树的高度为3）。这样一来，在合并操作的时候就能通过这个权值的大小来决定谁当谁的上级
```c++
void union(int x,int y)
{
    x=find(x);							//寻找 x的代表元
    y=find(y);							//寻找 y的代表元
    if(x==y) return ;					//如果 x和 y的代表元一致，说明他们共属同一集合，则不需要合并，直接返回；否则，执行下面的逻辑
    if(rank[x]>rank[y]) pre[y]=x;		//如果 x的高度大于 y，则令 y的上级为 x
    else								//否则
    {
        if(rank[x]==rank[y]) rank[y]++;	//如果 x的高度和 y的高度相同，则令 y的高度加1
        pre[x]=y;						//让 x的上级为 y
    }
}
```
* 附图如下：
* ![image](https://github.com/Vajackye/vajackye-now/assets/121871885/8ff3397f-86e8-44b5-b493-9ebc744feb7b)
* ![image](https://github.com/Vajackye/vajackye-now/assets/121871885/1a059591-da1e-41ca-a62f-d6aae897fcf4)

* 1、如果`rank[x] < rank[y]`，则令`pre[x] = y`；2、如果`rank[x] == rank[y]`，则可任意指定上级；3、如果`rank[x] > rank[y]`，则令`pre[y] = x`；


* 所有操作总结
```c++
const int  N=1005					//指定并查集所能包含元素的个数（由题意决定）
int pre[N];     					//存储每个结点的前驱结点 
int rank[N];    					//树的高度 
void init(int n)     				//初始化函数，对录入的 n个结点进行初始化 
{
    for(int i = 0; i < n; i++){//下标从某处开始。看题目给定的起始下标是多少。
        pre[i] = i;     			//每个结点的上级都是自己 
        rank[i] = 1;    			//每个结点构成的树的高度为 1 
    } 
}
int find(int x)     	 		    //查找结点 x的根结点 
{
    if(pre[x] == x) return x;  		//递归出口：x的上级为 x本身，则 x为根结点 
    return find(pre[x]); 			//递归查找 
} 
 
int find(int x)     				//改进查找算法：完成路径压缩，将 x的上级直接变为根结点，那么树的高度就会大大降低 
{
    if(pre[x] == x) return x;		//递归出口：x的上级为 x本身，即 x为根结点 
    return pre[x] = find(pre[x]);   //此代码相当于先找到根结点 rootx，然后 pre[x]=rootx 
} 

bool isSame(int x, int y)      		//判断两个结点是否连通 
{
    return find(x) == find(y);  	//判断两个结点的根结点（即代表元）是否相同 
}

bool join(int x,int y)
{
    x = find(x);						//寻找 x的代表元
    y = find(y);						//寻找 y的代表元
    if(x == y) return false;			//如果 x和 y的代表元一致，说明他们共属同一集合，则不需要合并，返回 false，表示合并失败；否则，执行下面的逻辑
    if(rank[x] > rank[y]) pre[y]=x;		//如果 x的高度大于 y，则令 y的上级为 x
    else								//否则
    {
        if(rank[x]==rank[y]) rank[y]++;	//如果 x的高度和 y的高度相同，则令 y的高度加1
        pre[x]=y;						//让 x的上级为 y
	}
	return true;						//返回 true，表示合并成功
}
```
-----
### 树状数组
* 用数组来模拟树形结构
* 树状数组用于解决：区间更新，单点查询。
* 知识点：`lowbit(x)`运算：计算一个非负整数n在二进制下的最低为1及后面的0构成的数，即`lowbit(x) = x&(-x);`
* 码蹄集：快排变形
```c++
#include<bits/stdc++.h> 

using namespace std;
const int N = 2e5+10;
int a[N], b[N], c[N], n;
long long ans;

int lowbit(int x) { return x & -x;}
void add(int i, int x)
{
    for(; i <= n; i += lowbit(i))
        c[i] += x;
}
int sum(int i)
{
    int ans = 0;
    for(; i > 0; i -= lowbit(i))
        ans += c[i];
    return ans;
}
bool cmp(const int x, const int y)
{
    if(b[x] == b[y])   
        return x > y;
    return b[x] > b[y];
}
int main( )
{
    cin>>n;
    for(int i = 1; i <= n; i++)
    {
        cin >> b[i];
        a[i] = i;
    }
    sort(a + 1, a + n + 1, cmp);
    for(int i = 1; i <= n; i++)
    {
        add(a[i], 1);
        ans += sum(a[i] - 1);
    }
    cout << ans << endl;
    return 0;
}
```
<u\>https://blog.csdn.net/weixin_59670163/article/details/125190268<\u>
