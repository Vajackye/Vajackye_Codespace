* 质因数分解：任何大于 1 的正整数都能 唯一 的分解为有限个质数的乘积。根据这一定理任何一个合数都可以被分解成几个质数相乘的形式。
  * 可用于：求解约数个数，约数的和。因为某个正整数的约数也肯定等于质因数分解后的不同幂的乘积。
  * 方法一：如360：360/2 = 180/2 = 90/2 = 45/3 = 15/3 = 5; 所以360的质因数乘积为2^3 * 3^2 * 5^1; 则其约数共有（3+1）（2+1）（1+1）= 24个，即0-k次幂
  * 方法二：对于每个数，其约数总是成对出现的，比如 12 = 3 * 4 = 2 * 6..... 所以，我们只需要遍历到 (i = 2; i * i <= n; i++)即可。唯一要注意的点就是，若 i * i = n; 则只有一个约数，比如 25 = 5^2
  * 如本题：求一个正整数的约数的个数
  * ```c++
     //法1：质因数分解
     #include<iostream>
     using namespace std;
     int main()
     {
       int n;
       int ans = 1;
       cin>>n;
       for(int i = 2; i*i <= n; i++)
       {
         int tmp = 0;
         while(n % i == 0) // 缩小n，加快速度，毕竟如 360 = 2^3 * 3^2 * 5^1, 当除了3次2，则剩下的数就缩小了。注：肯定都是质数，因为如4，已经被2除过了，所以%4 != 0, 即合数都不可能出现，已被拆分为质数了
         {
           tmp++;
           n /= i;//缩小
         }
         ans *= (tmp + 1);//+1是因为0次幂
       }
       if(n != 1)
         ans *= (1+1); //最后一个质数，比如上面的5，单独的
       cout << ans;
       return 0;
     }

       //法2：暴力求解 i*i <= n
       /*
       int main()
       {
         int n;
         int ans = 0;
         cin>>n;
         for(int i = 2; i*i <= n; i++)
         {
           if( n % i == 0)//找约数,加法，不存在合数被质数拆分
             ans += 2;
           if( i * i == n)
             ans--;
         }
         cout<<ans;
         return 0;
       }
       */
    ```

  * 题2：求约数之和; 原本的拆分质因数公式就是：y = p1^k * p2^m * p3^n * ....
  * 即约数之和可以写为：(p1^0 + p1^1 + ... + p1^k) * (p2^0 + p2^1 +.....+ p2^m) *.....*(P.^0 + ......+ p.^y); `约数的每一个次幂都出现的乘积和`
    * 进一步化简公式就是：等比数列求和: a1[p1^(k+1) - 1]/(p1 - 1) * ....(p != 1; 其中的a1就是p1^0，首项，为1)
    * 代码如下：
    *  ```c++
       #include<iostream>
       using namespace std;
       int main()
       {
         int n;
         cin >> n;
         int ans = 1;
         for( int  i = 2; i*i <= n; i++)
         {
              int tmp = i;
              while( n % i == 0)
              {
                  tmp *= i;
                  n /= i;
              }
              ans *= (tmp - 1) / (i - 1);//a1=1
         }
          if(n != 1)
              ans *= (n + 1); // 因为（n^2 -1）/(n-1)
          cout<<ans;
          return 0;
       }

  * 题3：求模数：给定两个整数a, b; 问有多少个x，使得满足等式a mod x = b,  如果存在无限个，输出"infinity", 否则输出满足条件x的个数。
  * 解析如下：
    * 如果a==b , 只要mod的x大于a或b，肯定有无数个，比如 3 mod 4/5/6/7.... = 3
    * 如果a<b, 则不存在mod x使得 等于b 为0
    * 如果a>b, 则求(a - b) mod x == 0 , 那么只要对(a - b)取约数，只要找到 i < b, 则+1，其中i从1开始。约数成对出现，要保证其另一个约数也大于b，则再++（并且该约数不能 (a - b) / i = i）
  * 代码如下：
  * ```c++
    #include<bits/stdc++.h> 

    using namespace std;

    int main( )
    {
        int a, b;
        cin >> a >> b;
        if(a == b)
        {
            cout << "infinity";
            return 0;
        }
        if( a < b)
        {
            cout << '0';
            return 0;
        }
        a -= b;
        int ans = 0;
        for(int i = 1; i * i <= a; i++) //从一开始，不是完全素数
        {
            if(a % i == 0)
            {
                if(i > b) ans++;
                if(a / i > b && a / i != i) ans++;
            }
        }
        cout << ans;
        return 0;
    }
    ```

    * 题四:数树：在第一象限的坐标系中，若某点与（0，0）连线成的树没有被其他树覆盖，就称该树是可见的。比如：（5，3）可见，（4，2）不可见，因为被（2，1）覆盖。请计算n*n范围内可见树
    * 题解：n=(0,2000),c=(0,10)
    * ```c++
      #include<bits/stdc++.h> 

      using namespace std;
      //即a mod b == 1 ; b mod a == 1; 即最大公约数为1即可见。否则有约数都会被约数更小覆盖。
      int gcd(int x, int y)
      {
          return y == 0 ? x : gcd(y, x%y);
      }
      
      int main( )
      {
          int c;
          cin>>c;//测试数据组
          for(int i = 1; i <= c; i++)
          {
              int ans = 0;
              int n;
              cin>>n;
              for(int j = 1; j <= n; j++)
                  for(int k = 1; k <= n; k++)
                      if(gcd(k, j) == 1)
                          ans++; 
              cout<<i<<" "<<n<<" "<<ans+2<<endl;//不要忘了坐标轴的两条树
          }
          return 0;
      }
      ```

* 哥德巴赫猜想：任何一个偶数可以拆成两个质数之和。（奇数可以拆成质数和偶数之和，偶数如果为2则也为奇数，如果>2,则也可以拆成两个质数）
  * 相关题目：交税，税收是n收入的最大因子（不包含本身n的因子），为了减少税钱，把n拆成多份，使得交的钱最少
  * 代码：
  * ```c++
    #include <bits/stdc++.h>
    using namespace std;
    int n;
    bool prime(int num)
    {
       for (int i=2; i*i <= num; i++) {
          if (num %i== 0)
             return false;
       }
       return true;
    }
    int main()
    {
       cin>>n;
       if (prime(n))   cout << 1;
       else if (n %2==0)  cout << 2;
       else if (prime(n - 2))  cout << 2;//n-2如果等于质数，则为质数+2（质数），则只要交最大因子，各为1，共2，如果不是，则下面的输出，大于2的偶数拆成2个质数。
       else   cout << 3;
       return 0;
    }
    ```
    
          
