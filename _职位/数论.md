* 质因数分解：任何大于 1 的正整数都能 唯一 的分解为有限个质数的乘积。根据这一定理任何一个合数都可以被分解成几个质数相乘的形式。
  * 可用于：求解约数个数，约数的和。因为某个正整数的约数也肯定等于质因数分解后的不同幂的乘积。
  * 方法一：如360：360/2 = 180/2 = 90/2 = 45/3 = 15/3 = 5; 所以360的质因数乘积为2^3 * 3^2 * 5^1; 则其约数共有（3+1）（2+1）（1+1）= 24个，即0-k次幂
  * 方法二：对于每个数，其约数总是成对出现的，比如 12 = 3 * 4 = 2 * 6..... 所以，我们只需要遍历到 (i = 2; i * i <= n; i++)即可。唯一要注意的点就是，若 i * i = n; 则只有一个约数，比如 25 = 5^2
  * 如本题：求一个正整数的约数的个数
  * ```c++
     //法1：质因数分解
     #include<iostream>
     using namespace std;
     int main()
     {
       int n;
       int ans = 1;
       cin>>n;
       for(int i = 2; i*i <= n; i++)
       {
         int tmp = 0;
         while(n % i == 0) // 缩小n，加快速度，毕竟如 360 = 2^3 * 3^2 * 5^1, 当除了3次2，则剩下的数就缩小了。注：肯定都是质数，因为如4，已经被2除过了，所以%4 != 0, 即合数都不可能出现，已被拆分为质数了
         {
           tmp++;
           n /= i;//缩小
         }
         ans *= (tmp + 1);//+1是因为0次幂
       }
       if(n != 1)
         ans *= (1+1); //最后一个质数，比如上面的5，单独的
       cout << ans;
       return 0;
     }

       //法2：暴力求解 i*i <= n
       /*
       int main()
       {
         int n;
         int ans = 0;
         cin>>n;
         for(int i = 2; i*i <= n; i++)
         {
           if( n % i == 0)//找约数,加法，不存在合数被质数拆分
             ans += 2;
           if( i * i == n)
             ans--;
         }
         cout<<ans;
         return 0;
       }
       */
 ```

  * 题2：求约数之和
  * 即约数之和可以写为：(p1^0 + p1^1 + ... + p1^k) * (p2^0 + p2^1 +.....+ p2^m) *.....*(P.^0 + ......+ p.^y);
