### 集合
* 集合是成员的一个群集，集合中成员可以是元素，也可以是集合。集合无序，互不相同。
* 表示方法：顺序存储（顺序表），链式存储（链表）

* 顺序表类的定义：
  ```c++
  const int stasize=100;
  class SeqList:public LinearList{
    protected:
      T* data; //存放的数组
      int maxsize;
      int last;
      void reSize(int newSize);
    public:
      SeqList(int sz = stastize);
      seqList(seqList& st);
      ~SeqList(){delete []data;}
      int Size(); //return maxsize
      int length(); //return last+1
      int Search(T x); //return index
      //......
  ```
  * 并&交运算实现：
    ```c++
    //并
    void union(SeqList A, SeqList B)
    {
      int len1 = A.length(), len2 = B.length();
      int i, k, x;
      for(i = 0; i < n2; i++)
      {
        x = B.getData(i);  //依次取元素
        k = A.search(x);  //查找是否在A中
        if(!k)
        {
          A.insert(x);//无x元素
          len1++;
        }
      }
    }
    //交
    void Intersection(SeqList A, SeqList B)
    {
      int len1 = A.length();
      int k, x, i=0;
      while(i < len1)
      {
        x = A.getData(i);
        k = B.search(x);
        if(!k)
        {A.remove(i, x);len1++;i++;}
        else i++;
      }
    }
    ```


  * 二.查找算法
    * 基于顺序结构的查找算法
    * 实现1(缺陷款:缺陷，谁会一个个的去问i<=n?)
      ```c++
      int search(int s[], int key, int n)
      {
        int i = 1; //从头查找
        while(s[i].key != key && i<=n)//缺陷，谁会一个个的去问i<=n?
          i++;
        if(i<=n) return i;
        else return 0;
      }
      ```
    * 实现2（改进：①从头到尾的监视哨；②从尾到头的监视哨)
      ```c++
      //头到尾的监视哨
      int search(int s[], int key, int n)
      {
        s[n+1].key = key; //设置多一位作为监视哨，到了就出去
        int i = 1;
        while(s[i]!=key) i++;
        if(i!=n=1) return i;
        else return 0;  //为监视哨，返回0未找到
      }
      ```
  
  * 基于有序顺序表的二分查找方法。（略，详见算法与数据结构内部（maybe））
    * 递归实现/非递归实现（循环）
-----------------------------------

* 链式结构
  * 并和交操作：
  * 代码略。（两个链表，A链给元素，B链拿着元素从头到尾遍历。并：如果没有，B链尾结点添加该元素；交：如果没有，A链表实行删除操作）

------------------------------------

* 树形结构
  * 索引顺序表
  * 如图：
  * ![image](https://github.com/Vajackye/Vajackye_Codespace/assets/121871885/6193e293-3a34-4caa-a07a-254a0ff6f22f)
  * 索引表结构：
    ```c++
    struct indexItem//索引项
    {
      int maxkey;  //最大key值
      int start;  //起始
    }indexTabel[Maxsize]; //索引表
    //顺序表
    struct rec
    {
      int key;
      //...
    }Table[n];
    ```
    * 查找过程：![image](https://github.com/Vajackye/Vajackye_Codespace/assets/121871885/e362918c-63a9-435e-8c27-ffcf171e7e01)

  * 树的合并操作：1.判断两个元素是否属于同一集合。2.合并两个不相交集合。(具体操作：并查集）
    * ![Uploading image.png…]()
----------------
#### 并查集
* 原理：处理一些不相交集合的合并问题。经典应用：连通图，最小生成树Kruskal算法和LCA等。
* 包含初始化，查找，合并，统计（统计根节点数量）等操作。进阶操作为：合并优化，路径压缩。
* 代码：
  ```c++
  const int N = 100;//可修改
  int f[N];
   //初始化集合为N个独立集合
  void init()
  {
    for(int i = 0; i < N; i++)
      f[i] = i;  //课本中为-1.统一为-1。此处为i，方便一些
  }
  //查找操作
  int find(int x)
  {
    return x == f[x]? x: find(f[x]);  //层层找根节点
    //第二种写法
    /*
      while(x!= f[x])
        x = f[x];
      return x;
    */
  }
  // 合并操作
  void union(int x, int y)
  {
    x = find(x); y = find(y); //找各自祖先，看是否一致，不一致，此处令x作为y的子女。
    if(x!= y) f[x] = f[y]; //此处的x，y为根节点。即将祖先作为另一个祖先的子女（即次祖先级别）。
  }
  //统计集合个数
  int calcu()
  {
    int sum = 0;
    for(int i = 0; i < N; i++)
      if(i==f[i]) sum++;
    return sum;
  }
  ```

  * 合并优化（即减小树的高度，令矮树接到高树上。同高任意）
    ```c++
    int f[N];
    int height[N];
    void init()
    {
      for(int i = 0; i < N; i++)
      {
        f[i] = i;  //自身独立集合
        height[i] = 0; //树高
      }
    }
    void union(int x, int y)
    {
      x = find(x); y = find(y); //找祖先
      if(height[x] == height[y]) //如果两个祖先由同高的树，则任意。此处令y树数根作为x树数根的子女（即次祖先）
      {
        height[x] += 1; //合并，高度+1,因为y树等高，往下挪1位，高度++
        f[y] = x;
      }
      else
      {
        if(height[x] < height[y]) s[x] = y;
        else s[y] = x;
      }
    }
    ```
        
  * 路径压缩（查询的优化）：
    ```c++
    //递归式
    int find(int x)
    {
      if(x != f[x]) f[x] = find(x);  //令途中每一个结点都往上找祖宗，最后把祖宗结点返回给每一个结点，最后成为1颗2层的n叉树。
      return f[x]; //返回祖宗
    }
    //非递归式
    int find(int x)
    {
      int fa = x;
      while(fa != f[fa]) fa = f[fa]; //找祖宗
      int add = x;
      int tmp;
      while(add != fa)
      {
        tmp = f[add];  //记录原来的父亲
        f[add]  = fa;  //令祖宗变为自己新父亲
        add = tmp;  //找回原父亲。
      }
      return fa;  //返回祖宗结点
    }
    ```
      
------------------
### 二叉查找树（二叉排序树，二叉搜索树）

    
  
    
