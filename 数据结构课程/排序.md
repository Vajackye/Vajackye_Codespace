# 排序
* 顺序表结构
  ```c++
  const int maxsize = 100;
  template<class T>
  class SeqList
  {
    public:
      T* data;
      int Msize;
      int last;
      SeqList(int sz = maxsize);  //构造函数
      int size() const {return Msize;}  //计算最大容量
      int length() const {return last+1;} //计算表长度
      int Search(T& x) const;
        //搜索x在表中位置，函数返回表项序号......
      void Sort();  //排序算法
  };
  ```
### 冒泡排序
* 
### 插入排序
* 直接插入排序
  * 当插入data[i]（i>=2)对象时，前面的data[1], data[2], ..., data[i-1]已经排好序。这是，用data[i]的排序码与data[i-1]，data[i-2],...的排序码顺序进行比较，找到插入位置即将data[i]插入，原来位置的对象往后移动。
  * 例如：已知一组待排序记录的排序码分别为40，30，60，90，70，10，20，40，用直接插入法排序。
  * 如图：
    ![image](https://github.com/Vajackye/Vajackye_Codespace/assets/121871885/80d15f28-527f-4a3b-9f0a-7630a5598bad)
  * 代码如下（优化1）：(注意：j>0,加上这个为讲稿优化。)
    ```c++
    void InsertSort()
    {
      int i, j;
      for(i = 2; i <= last; i++)  //依次将data[2],...data[last] 插入序列中
      {
        data[0] = data[i];
        j = i - 1;
        while( data[0] < data[j] ) //查找x（即原data[i]）的插入位置
          data[j+1] = data[j--]; //将序列中排序码大于x的记录往后移动。
        data[j+1] = data[0]; //填入data[i]
      }
    }
    ```
  * 链表版：
    * ![image](https://github.com/Vajackye/Vajackye_Codespace/assets/121871885/96402604-2764-48f5-ba98-1773ae41007b)
   
### 选择排序
* 
### 希尔排序
### 拓扑排序

### 堆排序
* 每次插入堆尾后，向上调整
* 每次删除堆头后，向下调整
* 向上调整：循环由son或father决定都可。son决定，则终止条件为son>1(若使用0号单元则，son>0)或father>=1(若使用0号单元则，father>=0)。原理是：每次交换后，son和father会向上调整一层，调到顶层，会有son==1, 或者最后一次调整，会有father==1。
* 代码如下:
  ```c++
  //即向下调整。代码完全一样。
  void adjust(int arr[], int start, int len)
  {
    int father = last; int son = last*2+1;
    int temp = arr[father];
    while(son<=len)
    {
      if(son<len && arr[son] < arr[son+1])son++;
      if(arr[son] > temp)
      {
        arr[father] = arr[son];
        father = son;
        son = father*2;
      }
      else break;
    arr[father] = temp;
  }
  void HeapSort(int arr[], int size)
  {
    for(int i = size/2-1; i >= 0; i--)//从最后一个非叶子结点向上调整。从下网上是因为：下调整好了，上往下调整后，依然保持有序。若上往下调整，调整一次后，仍上部可能有大小原因。
      adjust(arr, i, size-1);//从0开始，故-1
    //排序部分
    for(int i = size-1; i > 0; i--) //大于0，因为最后只有一个元素即，i=0时，就剩一个元素，不需要排序。
    {
      int temp = arr[i];
      arr[i] = arr[0];
      arr[0] = arr[i];
      adjust(arr, 0, size-1);//头向下调整。
  }
  ```
### 快速排序
* 找基准值（一般为方便，选第一个元素为基准值。
* 先从右往左找第一个小于基准值的value，置给基准值的位置。然后该位置空，从左往右找第一个大于基准值的值，将其置给前面这个数的位置。（即一直对调，直到左右指针相遇。）
* 最后将基准值置入最后一个被置换走的元素位置处。然后将以基准值为分界线，其左部分与右部分依次递归上述操作。（当元素为1时，即开始双指针就相遇时为递归终止返回条件。）
* 代码如下：
  ```c++
  int QPass(int elem[], int low, int high)
  {
    int l = low, r= high;
    int standard = elem[low];
    while(l<r)
    {
      while(l<r&&elem[r]>=standard) r--; //从右往左找第一个小于基准值standard的value
      if(l<r) elem[l++] = elem[r];
      while(l<r&&elem[l]<=standard) l++; //从左往右找第一个小于基准值standard的value
      if(l<r) elem[r--] = elem[l];
    }
    elem[l] = standard;
    return l;//mid
  }

  void Qsort(int elem[], int low, int high)
  {
    int mid;
    mid = QPass(elem, low, high);
    Qsort(elem, low, mid-1);
    Qsort(elem, mid+1, high);
  }
  ```
### 归并排序
* 对有序数组进行二分，即:mid = (first+last)/2。不断递归二分，直到元素为1。（即：递归到最后一层，为终止条件）
* 对递归的元素每层合并。注意划分l与r。每次都需要借用一个辅组数组。再由辅助数组还给原数组。
* 空间复杂度为O(n).时间复杂度为O(nlogn)。
* 代码如下（不考，只需手工，此处看看即可）
  ```c++
  void merge(int* a, int low, int mid, int hight)  //合并函数
  {
  	int* b = new int[hight - low + 1];  //用 new 申请一个辅助函数
  	int i = low, j = mid + 1, k = 0;    // k为 b 数组的小标
  	while (i <= mid && j <= hight)  
  	{
  		if (a[i] <= a[j])
  		{
  			b[k++] = a[i++];  //按从小到大存放在 b 数组里面
  		}
  		else
  		{
  			b[k++] = a[j++];
  		}
  	}
  	while (i <= mid)  // j 序列结束，将剩余的 i 序列补充在 b 数组中 
  	{
  		b[k++] = a[i++];
  	}
  	while (j <= hight)// i 序列结束，将剩余的 j 序列补充在 b 数组中 
  	{
  		b[k++] = a[j++];
  	}
  	k = 0;  //从小标为 0 开始传送
  	for (int i = low; i <= hight; i++)  //将 b 数组的值传递给数组 a
  	{
  		a[i] = b[k++];
  	}
  	delete[]b;     // 辅助数组用完后，将其的空间进行释放（销毁）
  }
  void mergesort(int* a, int low, int hight) //归并排序
  {
  	if (low < hight)
  	{
  		int mid = (low + hight) / 2;
  		mergesort(a, low, mid);          //对 a[low,mid]进行排序
  		mergesort(a, mid + 1, hight);    //对 a[mid+1,hight]进行排序
  		merge(a, low, mid, hight);       //进行合并操作
  	}
  }
  ```
### 基数排序
### 计数排序
* 代码如下
  ```c++
   const int N = 1e6;
  int buck[N];
  void bucket(int wait_sort[], int n)
  {
    memset(buck, 0, sizeof(buck));
    for(int i = 0; i < n; i++) //统计
      buck[wait_sort[i]]++;

    int i = 0, j = 0;
    while( i < n)
    {
      while(buck[j]>0)
      {
        wait_sort[i++]=j;
        buck[j]--;
      }
      j++;
    }
    return ;
  }
  ```
### 桶排序
* 数组版
  ```c++
 
  
* 链表版（讲稿的）

### 
