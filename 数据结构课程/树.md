# 树的定义
## 树的性质
### 二叉树
* 二叉树的性质：
  * 二叉树第i层节点数量最多有`2^(i-1)`个
  * 深度为h的二叉树最多有`2^(h-1)`个结点
  * 具有n个结点的完全二叉树的深度为logN+1（log下取整）或log(n+1)上取整
* 二叉树的抽象数据类型：
 ![image](https://github.com/Vajackye/Vajackye_Codespace/assets/121871885/5ea6041f-48cd-4fc6-b2fb-e802565c20c6)

* 二叉树的存储表示：
  * 二叉树的数组式存储：
  * 二叉树的链表式存储：
  * 二叉树的遍历：
    * 递归式：
    * 非递归式：
      * 栈式模仿前中后序遍历
        ```c++
        //后序遍历的非递归，前序和中序只需改变visit输出结点的次序即可
        void BinaryTree<T>::PostOrder(void (*visit)(BinTreeNode<T>* p)
        { stack<BinTreeNode<T>*> s1;
          stack<int> s2;
          t=root;
          while((!s1.isempty()||(t!=0))) //栈非空或当前节点非空
          {
            while(t!=0) //当前结点非空
            {
              //visit(t); //前序遍历
              s1.push(t);
              s2.push(0);//当前节点和第一进栈标志进栈S
              t=t->leftchild; //当前节点的左孩子作为当前节点
             }
             if(!s.isempty()) //栈s非空
             {
               s1.pop(t);
               s2.pop(flag);  //s1,s2栈顶结点出栈
               if(flag == 1) //说明该结点是第二进栈结点
               {
                 visit(t); // 后序遍历处
                 t = 0;  // 空且栈空表示全部遍历完毕
               }
               else
               {
                 //visit(t); //中序遍历
                 s1.push(t);
                 s2.push(1); //结点第二次进栈s
                 t = t->rightchild; //以当前结点的右孩子作为当前结点
                }
              }
            }
          }
        *  ```
    * 层次式非递归：
      ```c++
        void BinaryTree<T>::levelOrder(void (*visit)(BinTreeNode<T> *p))
        {
            //层次遍历
            queue<BinTreeNode<T>*> q;
            //第一一个以二叉树节点数为容量的顺序队列对像
            t=root;
            if(t != 0)
                q.push(t); // 入列根节点
            while(!q.empty())//非空队列
            {
                t=q.top();
                q.pop();
                visit(t);//对节点t进行访问
                if(t->leftchild!=0)//左孩子非空，则入列
                    q.push(t->leftchild);
                if(t->rightchild!=0)//右孩子非空，入列
                    q.push(t->rightchild);
            }
        }
       ```

-----------------------
### 二叉树遍历的应用
* 二叉树的左右孩子的交换
  ```c++
  void PreOrder(BinTreeNode *t)
  {
      //前序遍历,通过改变前3行位置（两个pre之间为中序，之后为后序）
      if(t!=0)//二叉树非空
      {
          x = t->leftchild;
          t->leftchild = t->rightchild;
          t->rightchild = x;
          PreOrder(t->leftchild);
          PreOrder(t->rightchild);
      }
  }
  ```
* 求二叉树叶子总数
  ```c++
  void culmulate(BinTreeNode *t, int & counter)
  {
      //前序，（后序和中序改变if即可。也可以添加剪枝。比如if执行完了，后面俩子树都是空的，没必要继续）
      if(t!=0) // 二叉树非空
      {
          if(t->leftchild == 0 && t->rightchild == 0) counter++;
          culmulate(t->leftchild); // 对左子树进行遍历
          culmulate(t->rightchild); //队友子树进行遍历
      }
  }
  /*
  更简单的写法
  int leaves(BinTreeNode* t)
  {
  	if(t!=0) // 非空
  	{
  		if(t->left == 0 && t->right == 0) return 1;
  	}
  	else
  		return leaves(t->left) + leaves(t->right);
  }
  */
  ```
* 二叉树的生成（创建二叉树）
  ```c++
  // 根据需求，选定一个终止字符，不然一直递归左左左左左.....不停，必须有终止符
  BinTreeNode* creat(void)
  {
      char ch;
      BinTreeNode* cur;
      cin>>ch;
      if(ch == '.') // 此处用.作为切换孩子的信号（.代表输入空）
          return 0; // 建立空树
      
  	 cur = new BinTreeNode(ch); // 分配节点
       cur->left = creat(); //建立左子树
       cur->right = creat(); //建立右子树
       return cur;
  }
  /* 中序建立
   {  char ch;
      BinTreeNode* cur ,*q;
      cin>>ch;
      if(ch == '.') // 此处用.作为切换孩子的信号（.代表输入空）
          return 0; // 建立空树
      
  	 q = creat(); // 建立左子树
  	 cur = new BinTreeNode(ch); //建立中点
       cur->left = q;
       cur->right = creat(); //建立右子树
       return cur;
    }
    
    后序遍历
     {  char ch;
      BinTreeNode* cur ,*l, *r;
      cin>>ch;
      if(ch == '.') // 此处用.作为切换孩子的信号（.代表输入空）
          return 0; // 建立空树
      
  	 l = creat(); // 建立左子树
  	 r = creat(); // 建立右子树
  	 cur = new BinTreeNode(ch); //建立中点
       cur->left = l;
       cur->right = r; //建立右子树
       return cur;
    }
    
  //层序遍历
  {  char ch;
    	queue<BinTreeNode* > q;
      BinTreeNode* cur;
      cin>>ch;
      if(ch == '.') // 此处用.作为切换孩子的信号（.代表输入空）
          return 0; // 建立空树
      
  	cur = new BinTreeNode(ch); // 创建
      q.push(cur);
      while(!q.empty())
      {
      	BinTreeNode* now;
      	now = q.top();
      	q.pop();
      	cin>>ch;
      	if(ch == '.') // 此处用.作为切换孩子的信号（.代表输入空）
          	now->left = NULL;
          else
          {
          	BinTreeNode* p = new BinTreeNode(ch);
          	now->left = p;
          	q.push(p);
          }
          if(ch == '.')
          	now->right = NULL;
          else
          {
          	BinTreeNode* p = new BinTreeNode(ch);
          	now->right = p;
          	q.push(p);
          }	
      }
   }
  */
  ```
  * 复制二叉树


  
