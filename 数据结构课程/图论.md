# 图
### 图的基本概念
* 图定义：图是由顶点集合（Vertex）以及顶点间的关系集合组成的一种数据结构：Graph=（V，E）。其中，V={x|x属于某个数据都西昂}，是顶点的有穷非空集合。
* 有向图与无向图：<x,y>是有序的。边<x,y>称为弧，x为弧尾，y为弧头。(x,y)是无序的。
* 完全图：
  * ![image](https://github.com/Vajackye/Vajackye_Codespace/assets/121871885/bad491c6-e3a3-4b53-bca5-cdb8bcd0dec7)
* 邻接顶点： 子图（设两个图，G=(V,E),和G'=(V', E')。若V' 属于 V 且 E'属于E，则称图G'是图G的子图。（即连通分量。）
  * 如图：
  * ![image](https://github.com/Vajackye/Vajackye_Codespace/assets/121871885/f47e3868-eff2-4765-a370-7ee7b1e51dce)

* 带权图：也叫网络。稠密图和稀疏图， e < nlogn
* 顶点的度：入度，出度，路径。

* 路径长度：
  * 简单路径：若路径上各顶点 v1，v2，.....，v3，v4均不互相重复，则称这样的路径为简单路径
  * 回路：若路径上第一个顶点V1与最后一个顶点Vm重合。则称这样的路径为回路或环。
  * 图片：
    ![image](https://github.com/Vajackye/Vajackye_Codespace/assets/121871885/fe420ea7-d783-421c-96d9-c91150c0b1f6)

  * 连通图与连通分量
  * 强连通图与强连通分量
  * 生成树：一个连通图的生成树是其极小连通子图。
  
  * 操作的归纳
    * 图的抽象数据类型
    ```c++
    class Graph{
    //对象：由一个顶点的非空集合和一个边集合构成
    //每条边由一个顶点对来表示。
    public:
     Graph();  //建立一个空的图
    //插入一个顶点vertex，该顶点暂时没有入边
     void insertVertex(const T& vertex);
    //在图中插入一条边(v1,v2,w)
     void insertEdge(int v1, int v2, int weight);
    //在图里删除顶点v和所有关联到它的边.
     void removeVertex(int v);
    //在图中删去边（v1，v2）
     void removeEdge(int v1, int v2);
    //若图中没有顶点，则返回true，否则返回false
     bool IsEmpty();
    //函数返回边(v1, v2)的权值
     T getWeight(int v1, int v2);
    //给出顶点v第一个邻接顶点的位置
     int getFirstNeighbor(int v);
    //给出顶点v的某邻接顶点w的下一个邻接顶点
    int getNextNeighbor(int v, int w);
    };
    ```
    * 图的模板基类
      ```c++
      const int maxWeight = .......; //无穷大的值
      const int DefaultVerticces = 30;  //最大顶点数
      template<class T, class E>
      class Graph  //图的类定义
      {  
        protected:
         int maxVertices;  //图中最大顶点数量
         int numEdges;  //当前边数
         int numVertices;  //当前顶点数
         int getVertexPos(T vertex);  //给出顶点vertex在图中位置
        public:
         Graph(int sz = DefaultVertices);  //构造函数
         ~Graph();  //析构函数
         bool GraphEmpty() const  { return numEdges == 0;} //判图空否
         int NumberOfVertices() {return numVertices; }  //返回当前边数
         virtual T getValue(int i);  //取顶点i的值
         virtual E getWeight(int v1, int v2);  //取边上的权值
       
   
    

