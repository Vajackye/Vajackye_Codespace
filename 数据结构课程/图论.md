# 图
### 图的基本概念
* 图定义：图是由顶点集合（Vertex）以及顶点间的关系集合组成的一种数据结构：Graph=（V，E）。其中，V={x|x属于某个数据都西昂}，是顶点的有穷非空集合。
* 有向图与无向图：<x,y>是有序的。边<x,y>称为弧，x为弧尾，y为弧头。(x,y)是无序的。
* 完全图：
  * ![image](https://github.com/Vajackye/Vajackye_Codespace/assets/121871885/bad491c6-e3a3-4b53-bca5-cdb8bcd0dec7)
* 邻接顶点： 子图（设两个图，G=(V,E),和G'=(V', E')。若V' 属于 V 且 E'属于E，则称图G'是图G的子图。（即连通分量。）
  * 如图：
  * ![image](https://github.com/Vajackye/Vajackye_Codespace/assets/121871885/f47e3868-eff2-4765-a370-7ee7b1e51dce)

* 带权图：也叫网络。稠密图和稀疏图， e < nlogn
* 顶点的度：入度，出度，路径。

* 路径长度：
  * 简单路径：若路径上各顶点 v1，v2，.....，v3，v4均不互相重复，则称这样的路径为简单路径
  * 回路：若路径上第一个顶点V1与最后一个顶点Vm重合。则称这样的路径为回路或环。
  * 图片：
    ![image](https://github.com/Vajackye/Vajackye_Codespace/assets/121871885/fe420ea7-d783-421c-96d9-c91150c0b1f6)

  * 连通图与连通分量
  * 强连通图与强连通分量
  * 生成树：一个连通图的生成树是其极小连通子图。
  
  * 操作的归纳
    * 图的抽象数据类型
    ```c++
    class Graph{
    //对象：由一个顶点的非空集合和一个边集合构成
    //每条边由一个顶点对来表示。
    public:
     Graph();  //建立一个空的图
    //插入一个顶点vertex，该顶点暂时没有入边
     void insertVertex(const T& vertex);
    //在图中插入一条边(v1,v2,w)
     void insertEdge(int v1, int v2, int weight);
    //在图里删除顶点v和所有关联到它的边.
     void removeVertex(int v);
    //在图中删去边（v1，v2）
     void removeEdge(int v1, int v2);
    //若图中没有顶点，则返回true，否则返回false
     bool IsEmpty();
    //函数返回边(v1, v2)的权值
     T getWeight(int v1, int v2);
    //给出顶点v第一个邻接顶点的位置
     int getFirstNeighbor(int v);
    //给出顶点v的某邻接顶点w的下一个邻接顶点
    int getNextNeighbor(int v, int w);
    };
    ```
    * 图的模板基类
      ```c++
      const int maxWeight = .......; //无穷大的值
      const int DefaultVerticces = 30;  //最大顶点数
      template<class T, class E>
      class Graph  //图的类定义
      {  
        protected:
         int maxVertices;  //图中最大顶点数量
         int numEdges;  //当前边数
         int numVertices;  //当前顶点数
         int getVertexPos(T vertex);  //给出顶点vertex在图中位置
        public:
         Graph(int sz = DefaultVertices);  //构造函数
         ~Graph();  //析构函数
         bool GraphEmpty() const  { return numEdges == 0;} //判图空否
         int NumberOfVertices() {return numVertices; }  //返回当前边数
         virtual T getValue(int i);  //取顶点i的值
         virtual E getWeight(int v1, int v2);  //取边上的权值
         //取顶点v的第一个邻接顶点
         virtual int getFirstNeighbor(int v);
         //取邻接顶点w的下一邻接顶点
         virtual int getNextNeighbor(int v);
         //插入一个顶点vertex
         virtual bool insertVertex(const T vertex);
         //插入边(v1, v2), 权为cost(带权图)
         virtual bool insertEdge(int v1, int v2, E cost);
         //删除顶点v和所有与之相关的边
         virtual bool removeVertex(int v);
         //删去边(v1, v2)
         virtual bool removeEdge(int v1, int v2);
      };
      ```
    * 如图：
      * ![image](https://github.com/Vajackye/Vajackye_Codespace/assets/121871885/c3e40264-d913-491a-b3d0-dbde60cd9faf)

* 两种存储方式：
  * 邻接矩阵（相邻矩阵）
    * 无权式如图：
      * ![image](https://github.com/Vajackye/Vajackye_Codespace/assets/121871885/b8d286e3-b7e1-4bb1-b99e-b012ed2c9977)
    * 有权式如图：
      * ![image](https://github.com/Vajackye/Vajackye_Codespace/assets/121871885/157a02b5-1261-4720-b2b5-493e7b1e6866)
       
    * 实现：
      * 类定义&&实现：
        * ```c++
          template<class T, class E>
          class Graphmtx: public Graph<T, E>
          {
            friend istream& operator>> (istream& in, Graphmtx<T, E>&G);  //输入
            friend ostream& operator<< (ostream& out, Graphmtx<T, E>&G);  //输出
            private:
              T *VerticesList;  //顶点表
              E **Edge;  //邻接矩阵
              int getVertexPos(T vertex)
              {
                //给出顶点vertex在图中的位置
                for(int i = 0; i < numVertices; i++)
                if(VerticesList[i] == Vertex) return i;
                return -1;
              }
            public:
          }
          ......//看书吧
          ```
    * 剩余部分，如图：
    * ![image](https://github.com/Vajackye/Vajackye_Codespace/assets/121871885/7a1897b7-4651-4316-b217-8cc76f1ccca6)
            

    * 如图：
    * ![image](https://github.com/Vajackye/Vajackye_Codespace/assets/121871885/895be4d8-2100-42b8-869f-8ffeda641c33)
    * ![image](https://github.com/Vajackye/Vajackye_Codespace/assets/121871885/4b755388-d0d6-45ac-960e-8aa12bb456b4)
            
* 邻接表
  * 无向图的邻接表
  * 将与同一顶点相邻接的顶点链接称一个单链表
  * 如图：
  * ![image](https://github.com/Vajackye/Vajackye_Codespace/assets/121871885/f8fa8251-8ad0-4d36-a985-b63d6317cd24)
         
  * 有向图的邻接表和逆邻接表
  * 如图：
  * ![image](https://github.com/Vajackye/Vajackye_Codespace/assets/121871885/5af70324-d0bb-499d-9f8f-9d58a17697e5)
  * 带权图（网络）的邻接表
  * 如图：
  * ![image](https://github.com/Vajackye/Vajackye_Codespace/assets/121871885/c0f5993f-9153-4988-86b8-e273f60abec2)
    
  * 邻接表存储图的类定义：
  * 如图：
  * ![image](https://github.com/Vajackye/Vajackye_Codespace/assets/121871885/ed20bbcb-8fb8-4d2f-bd9a-810d78744a80)
  * ![image](https://github.com/Vajackye/Vajackye_Codespace/assets/121871885/1409cfa1-6a32-4279-b2c8-a3c33c757329)
  * ![image](https://github.com/Vajackye/Vajackye_Codespace/assets/121871885/72a5b834-4358-46ff-a5cc-0071857e4959)
       
  * 邻接表的实现算法
    * 在输入数据前，顶点表NodeTable[]全部初始化，即将第i个结点的数据存入NodeTable[i].data中；接着把所有第i个结点的邻接点组成一个单链表
    * 方法：在输入数据时，每输入一条边<i,k>，就需要建立一个边结点，并将其接入相应边链表中。
    * ```c++
      Edge<T, E>*p = new Edge<T, E>;
      p->dest = k; //建立边结点，dest为k，即指向结点。（son）
      p->cost = xxx;  //即看题目，该边的权值有无
      p->link = NodeTable[i].adj; //头插入的方法，插到父母结点身上。
      NodeTable[i].adj = p;  //头插法。
      ```
    * 具体解释如图：
    * ![2f9ac78015898f9d28fdb3e24902676](https://github.com/Vajackye/Vajackye_Codespace/assets/121871885/4d49b917-66f9-49a0-a1b3-039fd1823950)
     
    * 邻接表的建立算法：
      ```c++
      void Graph<T,E>::CreatNodeTable(void) //学一下函数指针  //建立邻接表结构
      {
        int n,i,j,m;
        Edge<T, E> *p;
        cin>>n;   //结点个数
        for(int i=1; i<=n; i++)
        {
          NodeTable[i].adj=0; //预设为空链，见上我画的图
          cin>>NodeTable[i].data;/输入结点值
          cin>>m; //每个结点的邻接结点个数（即son）
          for(j=0; j<m; j++)
          {
            p=new Edge<T, E>;  //生成一个新节点（即邻接结点）
            cin>>p->dest;  //建立结点，输入值
            //如果是带权图，多加一个权值cin>>p->cost
            p->link = NodeTable[i].adj;
            Nodetable[i].adj = p;
           }
         }
      }
      ```
-------------------------------

### 图的遍历
* DFS&&BFS
* 存储结构：
  * 先回顾一下二叉树前序遍历的算法
  ```c++
  struct treenode
  {
    int data;
    treenode* child[2];//左右孩子
  };

  //前序遍历算法----（类比）----深度优先遍历算法
  void dfs(treenode* root)
  {
    int i;
    if(root!=0) //非空
    {
      cout<<root->data<<" ";
      for(int i= 0; i < 2; i++)
        dfs(root->child[i]);
  }

  //深度优先遍历算法
  void dfs(treenode *root)
  {
    int i;
    if(root!=0)
    {
      cout<<root->data<<" ";
      i = 0;
      while(i<2){
        dfs(root->child[i];
        i++;
      }
    }
  }

  //层序遍历算法----(类比）----广度优先算法
  void bfs(treenode *root)
  {
    queue<treenode *> que;
    treenode *temp;
    que.push(root);
    while(!que.empty())
    {
      temp = que.front();
      que.pop();
      cout<<temp->data<<" ";
      for(int i = 0; i < 2; i++)
        if(temp->child[i])
          que.push(temp->child[i]);
    }
  }

  //广度优先遍历算法
  void bfs(treenode *root)
  {
    queue<treenode*> que;
    treenode* temp;
    que.push(root);
    while(!que.empty())
    {
      temp=que.front();
      que.pop();
      cout<<temp->data<<" ";
      i=0;
      while(i<2)
      {
        if(temp->child[i])
        que.push(temp->child[i]);
        i++;
      }
    }
  }
  ```
* 再对比以邻接表为形式的DFS与BFS实现算法。
* 深度优先：
  ```c++
  ```
-----------------------------------

### 最小生成树
* n阶连通图选择n-1条边，构成导出子图，且该图为树，且权值和为最小。
  
* 算法1:Kruskal算法（贪心思想）
  * 构造非连通图ST=(V,{}) //其实是并查集
  * k=i=0; //k统计已选中的边数
    ```c++
    while(k<n-1)
    {
      ++i;
      //检查边集E中第i条权值最小的边(u,v);
      //若(u,v)加入ST后使得ST不产生回路，则k++
    }
    ```
  * 找权值最小边：1.（可以存入数组中，排序，逐个遍历）。2.用堆实现。
    ```c++
    struct MSTEdgeNode
    {
       int tail ,head; //两个顶点位置
       E cost;  //<重载
    };
    MinHeap<MSTEdgeNode<T, E> >H(m);  //最小堆
    ```
  * 判断存在回路
    * 并查集（判断所选择的边的两个顶点是否在同一集合中
  * 图的存储结构：
    * 1.邻接表 2.邻接矩阵 3.边集数组（即稀疏矩阵）。
  * 所有操作：
    ```c++
    //初始化部分。将所有权值插入堆中
    //图中所有边的数据（1结点，2结点，权值（边））插入堆中
    for(int u = 0; u < n; u++)//采用邻接表。只使用左上三角矩阵（因为左上右下对称）
    {
       for(int v = u+1; v<n; v++)
          if(Edge[u][v]<maxWeight)//是连通的，不连通则==maxWeight==∞
          {
            struct MSTEdgeNode ed;
            ed.tail = u; ed.head = v;
            ed.cost = Edge[u][v];
            //插入堆
            heap.insert(ed);
          }
    }

    //kruskal算法
    count=1; //最小生成树的边数计数
    while(count<n){ //取n-1条边
      struct MSTEdgeNode ed;
      ed = heap.top();
      heap.pop();
      //检查两个顶点是否在同一个集合，构成回路。回路则跳过到下一个结点。
      //用并查集check
      int u = check.find(ed.tail); int v = check.find(ed.head);
      if(u != v)
      {
        check.union(u,v); //不是一个集合，则合并。并算上该边。
        cout<<ed.tail<<ed.head<<ed.cost;//输出边
        count++;
      }
    ```
  * Kruskal算法总结：
    ![image](https://github.com/Vajackye/Vajackye_Codespace/assets/121871885/12a7a48e-c35b-4d68-ac27-b2a8f08ddb35)

  * Prim算法（贪心，选择最小边入树）
    * 构造：1.任取1点为出发点。2.将出发点作为第一组，其余点作为第二组。3.找边（一端属于第一组的点（即已遍历的），另一端为属于第二组的点。），找其中权值最小的一条。4.把该第二组点划为第一组点。5.反复2，3，4。直到第二组为空。
    * 图的存储结构：
    * 1.邻接表 2.邻接矩阵 3.边集数组（即稀疏矩阵）。

    * 如何找出权值最小的边？（最小堆）
   
    * 如何判断回路？（从堆取出的边，两个端点皆被访问。再次循环，直到从堆中取到满足3.中的边。）
    * 每次进行4.后，将所有其相邻的边都入堆。
   


-----------------------------
### 最短路径问题
* Dijkstra算法和Floyd算法

* Dijkstra算法：
-----------------------------
### 拓扑排序

    

        







   
    

