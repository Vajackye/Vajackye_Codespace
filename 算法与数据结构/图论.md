## 图论
* 无向图
* 有向图
* 带权有向图

### 图的存储
* 邻接矩阵
  * 直接用矩阵：graph[N][N]存储边。N为节点总数。结点范围编号：0~N-1。若i和j是**直连**的邻居，用graph[i][j]表示边（i，j）的权值。若不是邻居，通常将graph[i][j]赋为INF（无穷大）。
* 邻接表
  * 解决了邻接矩阵浪费空间问题。邻接表：即每个节点只存储它的**直连**邻居，一般用链表存储这些邻居，能存储重边。规模大的稀疏图一般用邻接表，因为非直连的节点不用存储，节省了空间，存储效率高。存储复杂度O(n+m)。
  * 缺点：找一个节点的邻居时，需要逐个遍历它的邻接表，不如邻接矩阵快。
  * 常用STL vector实现邻接表
    ```c++
    struct edge // 定义边
    {
      int from, to, w; // 边：起点为from，终点为to，权值为w
      edge(int a, int b, int c){from = a; to = b; w = c} //对边赋值
    };
    vector<edge> e[N]; //e[i]存储第i个节点连接的所有边（vector的push_back存储所有直接相连边）
    //初始化
    for(int i = 1; i <= n; i++)
        e[i].clear();
    //存边
    e[a].push_back(edge(a,b,c)); //把边(a,b)存到结点a的邻接表中
    //遍历结点u的所有邻居
    for(int i = 0; i < e[u].size(); i++)
    {
      int v = e[u][i].to, w = e[u][i].w;
      ...
    }
    ```

* 链式前向星
  * 用静态方法模拟邻接表
  * 



### 生成树
* 

### 最小生成树
* 这是最小生成树
* Kruskal算法（贪心操作）
* 将所有边带的权值从小到大排列，然后按最小边连接两边顶点，并判断两个顶点是否已经相连（即已被更小边连接），是则不连，否则连。
* 

* Prim算法
