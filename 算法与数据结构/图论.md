## 图论
* 无向图
* 有向图
* 带权有向图

### 图的存储
* 邻接矩阵
  * 直接用矩阵：graph[N][N]存储边。N为节点总数。结点范围编号：0~N-1。若i和j是**直连**的邻居，用graph[i][j]表示边（i，j）的权值。若不是邻居，通常将graph[i][j]赋为INF（无穷大）。
* 邻接表
  * 解决了邻接矩阵浪费空间问题。邻接表：即每个节点只存储它的**直连**邻居，一般用链表存储这些邻居，能存储重边。规模大的稀疏图一般用邻接表，因为非直连的节点不用存储，节省了空间，存储效率高。存储复杂度O(n+m)。
  * 缺点：找一个节点的邻居时，需要逐个遍历它的邻接表，不如邻接矩阵快。
  * 常用STL vector实现邻接表
    ```c++
    struct edge // 定义边
    {
      int from, to, w; // 边：起点为from，终点为to，权值为w
      edge(int a, int b, int c){from = a; to = b; w = c} //对边赋值
    };
    vector<edge> e[N]; //e[i]存储第i个节点连接的所有边（vector的push_back存储所有直接相连边）
    //初始化
    for(int i = 1; i <= n; i++)
        e[i].clear();
    //存边
    e[a].push_back(edge(a,b,c)); //把边(a,b)存到结点a的邻接表中
    //遍历结点u的所有邻居
    for(int i = 0; i < e[u].size(); i++)
    {
      int v = e[u][i].to, w = e[u][i].w;
      ...
    }
    ```

* 链式前向星
  * 用静态方法模拟邻接表
  * 链式前向星：存储一个节点u的邻接边，方法关键是：定位第一条边，第一条边再定位第二条边，第二条便再指向第三条边.....
    * head[u]指向u的一个邻居的存储位置（u是节点编号）。edge[i].to存储邻居节点编号（即第几个结点），next指向下一个邻居节点存储的位置。
    * 实现如下：
      ```c++
      #include<bits/stdc++.h>
      using namespace std;
      const int  N = 1e6+6, M = 2e6+5;  //100万个点，200万条边。
      int head[N], cnt;  // cnt记录当前存储位置
      struct
      {
        int from, to, next;  //from为边的起点u，to是边的中点v，next为u的下一个邻居。
        int w;
      }edge[M];  //存储边
      void init()
      {
        for(int i = 0; i < N; i++) head[i] = -1; //点初始化，head[i]为每个结点在邻接表里的下标，to指向该边的下一个邻居。
        for(int i = 0; i < N; i++) edge[i].next = -1; //边初始化
        cnt = 0; 
      }
      void addedge(int u, int v, int w)  //前向星存储边（u，v），边的权值为w
      {
        edge[cnt].from = u;  //一般，此句多余
        edge[cnt].to = v;
        edge[cnt].w = w;
        edge[cnt].next = head[u];
        head[u] = cnt++;  //存储位置移动
      ```
      * 简化写法：用0而不是-1表示空，省去init()函数

### 拓扑排序
* 事情的顺序关系和依赖关系
* 概念：设有a,b,c,d等事情。其中a最高优先级，b，c同优先级，d优先级最低，表示为a->(b,c)->d，则abcd，acbd都可行排序。事情看作图的点，先后关系看作有向边，问题转化为在图中求一个有先后关系的排序。
* 图能进行拓扑排序充要条件是：**有向无环图**,（拓扑排序可以找到环）


### 生成树
* 

### 最小生成树
* 这是最小生成树
* Kruskal算法（贪心操作）
* 将所有边带的权值从小到大排列，然后按最小边连接两边顶点，并判断两个顶点是否已经相连（即已被更小边连接），是则不连，否则连。
* 

* Prim算法
