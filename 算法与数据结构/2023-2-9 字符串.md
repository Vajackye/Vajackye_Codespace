```c++
  #include<string>
  int a = 12345;
  string c = to_string(a);//把数字常量转为字符串
  c.length(); c.size();//求字符串长度
  /* > string substr(int pos = 0,int n = npos) const;//返回pos开始的n个字符组成的字符串
     >> eg: string ss = s.substr(2); ss = s.substr(2,1);  --> 345  3*/ 
  /* >string &erase(int pos = 0, int n = npos);//删除pos开始的n个字符，返回修改后的字符串，源字符串也被修改
     >>string s = "hello,world!";  string ss1 = s.erase(6);	//删除下标为6的字符开始的所有字符-->hello;   
     >>string ss2 = s.erase(1,2);	//删除下标为2的字符开始的2个字符，删除el */
   /*  insert();//插入字符
     >>s.insert(0,"heo"); cout<<s<<endl;//整个字符串
	   >>s.insert(4,"world",2); cout<<s<<endl;//world的前2个字符
	   >>s.insert(2,2,'l');cout<<s<<endl;//插入单个字符2次 */
     
   /* stoi： string型变量转换为int型变量
      stol： string型变量转换为long型变量
      stoul：string型变量转换为unsigned long型变量
      stoll： string型变量转换为long long型变量(常用)
      stoull：string型变量转换为unsigned long long型变量
      stof： string型变量转换为float型变量
      stod： string型变量转换为double型变量(常用)
      stold：string型变量转换为long double型变量
      //eg:stoi(s);
      */
      
      /*C/C++函数，比较两个字符串 设这两个字符串为str1，str2， 若str1==str2，则返回零； 
      若str1 > str2，则返回正数；
      若str1< str2，则返回负数。
      即：两个字符串自左向右逐个字符相比（按ASCII值大小相比较），
      直到出现不同的字符或遇’0’为止。
      */
      
      isalnum();//判断是否为十进制数或者字符
      tolower();//大写变小写，其他类型字符不变
      sort(s.begin(), s.end());//可以直接用sort从小到大排序，不需要cmp，如果要从大到小排序：① ②先排序，然后reverse();
      sort(,,greater<>());sort(,,less<>())//两个函数在functional头文件中，greater从大到小排序，less从小到大排序。
```	
* string 之间 有 +=运算符（合并），但是没有 s = s + p;不能分开"+=";
* string 之间 没有 -=运算符
* string也有 push_back,pop_back运算符，估计vector有的string都有，因为string也相当于一个数组。
* npos函数：https://blog.csdn.net/guoqingshuang/article/details/80318476

* ** 关于printf输出字符串时乱码原因：https://www.cnblogs.com/cnhk19/p/15750051.html**
* 解决办法：.c_str();//字符串变量后添加





----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------

### 进制哈希
* BKDRHash:设定一个进制P，计算一个字符串的哈希值时，把每个字符串看作每个进制位上的一个数字，这个串转换为一个基于进制P的数，最后对M取余（一般假定M->unsigned long long），即得到该字符串的哈希值
* 即：进制转换，如：abc=》'a'*P^2 + 'b'*p^1 +'c'*p^0
* 模板题：给定N个字符传，第i个字符串长度Mi，字符串内包括数字和大小写字母，求N个字符串中共有多少个不同的字符串？
  ```c++
    #include<bits/stdc++.h>
	using namespace std;
	typedef unsigned long long ull;
	
	ull a[10010];
	string s;
	bool cmp(ull a, ull b)
	{
	    return a>b;
	}
	
	ull BKDRHash(string s)
	{
	    ull P = 131, H = 0;
	    int n = s.size();
	    for(int i = 0; i < n; i++)
	    {
	        H = H * P + s[i]-'a' + 1;
	    }
	    return H;//一个哈希函数值
	}
	
	int main()
	{
	    int n; 
	    cin>>n;
	    for(int i = 0; i < n; i++)
	    {
	        cin>>s;
	        a[i] = BKDRHash(s);  //存储每一个字符串的哈希值
	    }
	    
	    int ans = 0;
	    sort(a, a+n, cmp);
	    for(int i = 0; i < n; i++)
	    {
	        if(a[i] != a[i+1])
	        {
	            ans++;
	        }
	    }
	    cout<<ans;
	}
  ```
### Manacher算法求最长回文子串：
* 原理：
* ![image](https://github.com/Vajackye/Vajackye_Codespace/assets/121871885/bc4a7b5e-6fc8-4f9a-9042-bac166d71dd7)

* 模板题目：给出一个只由小写英文字符 a,b,c,…y,z组成的字符串 S ,求 S 中最长回文串的长度 。字符串长度为n
* ```c++
  #include<bits/stdc++.h>
	using namespace std;
	const int N = 11000002;
	int n, P[N << 1]; // p[i]为以s[i]为中心的回文半径，eg：10个字符，长度为5
	char a[N], s[N << 1]; //半径
	
	void change()  //添加分割符号，使得字串统一为奇数长字串
	{
	    n = strlen(a); // 长度
	    int k = 0; // 变革长度
	    s[k++] = '*'; s[k++] = '#'; //分隔符，最外层为"*","&",表示界限符号，防越界
	    for (int i = 0; i < n; i++)
	    {
	        s[k++] = a[i];
	        s[k++] = '#'; //每一个字符之间加分隔符
	    }
	    s[k++] = '&';
	    n = k; //更新长度
	
	
	}
	
	//Manacher算法
	void manacher()
	{
	    int R = 0, C;
	    for (int i = 1; i < n; i++)
	    {
	        if (i < R) P[i] = min(P[(C << 1) - i], P[C] + C - i); //合并两种情况，1.i的P[i]不超出R,2.i的P[i]超出R
	        else P[i] = 1; //从初始长度1个字符开始计算（1个字符半径为1）
	        while (s[i + P[i]] == s[i - P[i]]) P[i]++; //以i为半径，向左右拓展P[i](半径)个长度，回文则r++
	        if (P[i] + i > R) //新的最大R//即，不包括i在内。//即：在该i下，不断向右拓展，因为i++是往右的，一直往右拓展，能够找到每一个i的最大边界
	        {
	            R = P[i] + i;
	            C = i;
	        }
	    }
	}
	
	int main()
	{
	    scanf("%s", a);
	    change();
	    manacher();
	    int ans = 1;
	    for (int i = 0; i < n; i++) ans = max(ans, P[i]);
	    printf("%d", ans-1);
	    return 0;
	}
  ```

### 字典树
* 字典树，又称为**前缀树**
* 是回文树，AC自动机，后缀自动机等基础。
* 含义：在n个字符串内查找某个字符串，常规是O(nm)时间复杂度算法。即暴力。字典树为：类似查字典，查首字母，再通过首字母找到该部分（该树杈，子树），继续深入，一个个字母的查找。
* 字典树的节点的数据机构可以这样定义：
  ```c++
  struct TrieNode{
  	<Type> data;
  	bool isEndofWord;  //检查是否为单词字尾
  	TrieNode * children[SIZE];  //只想多个子结点，可能会有很多空指针。因为size大小固定？
  }
  ```
* 时间复杂度为O(m),但是空间复杂度高，即使多个字符串可共享一个相同前缀（父节点）。所以字典树是：空间换时间的数据结构。
* 常见应用：
  * 字符串检索。查询功能是基本功能。
  * 词频统计。统计一个单词出现的次数。
  * 字典序排序。插入时，在树的平级（即同一层的子结点？）按字母表的顺序插入。建好树后，前序遍历即可得到字典序的排序。（即，同级的，靠前的先遍历）
  * 前缀匹配。按公共前缀建树。适合搜索提示符。**比如输入一个命令的前几个字母，系统会自动补全命令后的字母（或者列出多条，同一树枝下的所有字母情况）**。

* 模板代码+解释：
  ```c++
	  const int N = 1000050;
	int trie[N][26];
	int cnt[N];//因为每一层都唯一一个字符，（由id），所以，cnt++1次表示，有一次输入是以该字符为结尾的。
	int id;//用来表示每个串中字符唯一信号，类似哈希。
	
	void insert(string s)
	{
		int p = 0;
		for (int i = 0; i < s.size(); i++)
		{
			int x = s[i] - 'a';
			if (trie[p][x] == 0) trie[p][x] = ++id; //存储下一个字符的位置
			p = trie[p][x];
		}
		cnt[p]++;//最后一个字符的位置为结尾位置。
	}
	
	int  find(string s)
	{
		int p = 0;
		for (int i = 0; i < s.size(); i++)
		{
			int x = s[i] - 'a';
			if (trie[p][x] == 0)return 0;
			p = trie[p][x];
		}
		return cnt[p];//返回最后一个字符的出现次数，如果为0表示没有这个字符作为终止符（即使路过，没统计过就不行）
	}
  ```
  * ![image](https://github.com/Vajackye/Vajackye_Codespace/assets/121871885/0277efe6-d750-411f-8b2a-11fc1c6eed71)


* 模板题：（洛谷8306）
* 
* 例题：（洛谷P2580）
* 给出学生人数和名单，教练点名。输入：第一行输入1个整数n，表示人数。接下来n行，每行输入一个字符串表示学生名字（互不同，且只含小写字母，长度不超过50）。第n+2行输入整数m，表示点名人数。接下来m行，每行一个字符串，表示点名名字（只含小写，不超50字母）。输出：对于每个教练报的名字，输出一行。如果该名字正确，且是第一次出现，输出`OK`,错误则输出`WRONG`,不是第一次念则`REPEAT`.
  ```c++
	 #include<bits/stdc++.h>
	using namespace std;
	const int N = 800000;
	struct node
	{
		bool repeat; //该前缀是否重复
		int son[26]; //26个字母
		int num;  //该前缀出现次数。 
	}t[N]; //字典树
	
	int cnt = 1; //当前新分配的存储位置，把cnt=0留给根节点，不存东西
	
	void insert(char* s) //插入新字母 
	{
		int now = 0; //子树位置(层数)
		for(int i = 0; s[i]; i++)  //此处s[i]表示遍历字符串？到了尾就停？ 
		{
			int ch = s[i] - 'a'; //求相对位置 
			if(t[now].son[ch] == 0)  //如果该字符还没有存储过 
				t[now].son[ch] = cnt++;  //把cnt位置分配给该字符，计数器。浪费空间太大了这题
			now = t[now].son[ch]; //沿着字典树向下走。
			t[now].num++;  //出现次数++ 
		 } 
	 } 
	 
	int Find(char* s)  //查找该字串 
	{
		int now = 0;
		for(int i =0; s[i]; i++)
		{
			int ch = s[i] - 'a';
			if(t[now].son[ch] == 0) return 3; // 第一个字符就找不到，这个3是主函数里的case 3
			now = t[now].son[ch];
		} 
		if(t[now].repeat == false) //第一次点名 
			{
				t[now].repeat = true;
				return 1;
			 } 
			 
		 
		  return 2;	 //遍历完了，存在但是重复点名。
		  //return t[p].num; //如有需要，返回以s为前缀的单词的数量 
	}
	 
	int main()
	{
		char s[51];
		int n;
		cin>>n;
		while(n--)
		{
			cin>>s;
			insert(s);
		}
		int m;
		cin>>m;
		while(m--)
		{
			cin>>s;
			int r = Find(s);
			if(r==1) cout<<"OK"<<endl;
			if(r==2) cout<<"REPEAT"<<endl;
			if(r==3) cout<<"WRONG"<<endl;
		}
		return 0;
	 } 
  ```
* 见图，cnt原理：（计数器，唯一映射，浪费太多空间）：
  ![image](https://github.com/Vajackye/Vajackye_Codespace/assets/121871885/5edeea1f-94e4-435a-8390-3e6ef61e51ea)

  
