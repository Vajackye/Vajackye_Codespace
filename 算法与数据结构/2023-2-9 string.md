```c++
  #include<string>
  int a = 12345;
  string c = to_string(a);//把数字常量转为字符串
  c.length(); c.size();//求字符串长度
  /* > string substr(int pos = 0,int n = npos) const;//返回pos开始的n个字符组成的字符串
     >> eg: string ss = s.substr(2); ss = s.substr(2,1);  --> 345  3*/ 
  /* >string &erase(int pos = 0, int n = npos);//删除pos开始的n个字符，返回修改后的字符串，源字符串也被修改
     >>string s = "hello,world!";  string ss1 = s.erase(6);	//删除下标为6的字符开始的所有字符-->hello;   
     >>string ss2 = s.erase(1,2);	//删除下标为2的字符开始的2个字符，删除el */
   /*  insert();//插入字符
     >>s.insert(0,"heo"); cout<<s<<endl;//整个字符串
	   >>s.insert(4,"world",2); cout<<s<<endl;//world的前2个字符
	   >>s.insert(2,2,'l');cout<<s<<endl;//插入单个字符2次 */
     
   /* stoi： string型变量转换为int型变量
      stol： string型变量转换为long型变量
      stoul：string型变量转换为unsigned long型变量
      stoll： string型变量转换为long long型变量(常用)
      stoull：string型变量转换为unsigned long long型变量
      stof： string型变量转换为float型变量
      stod： string型变量转换为double型变量(常用)
      stold：string型变量转换为long double型变量
      //eg:stoi(s);
      */
      
      /*C/C++函数，比较两个字符串 设这两个字符串为str1，str2， 若str1==str2，则返回零； 
      若str1 > str2，则返回正数；
      若str1< str2，则返回负数。
      即：两个字符串自左向右逐个字符相比（按ASCII值大小相比较），
      直到出现不同的字符或遇’0’为止。
      */
      
      isalnum();//判断是否为十进制数或者字符
      tolower();//大写变小写，其他类型字符不变
      sort(s.begin(), s.end());//可以直接用sort从小到大排序，不需要cmp，如果要从大到小排序：① ②先排序，然后reverse();
      sort(,,greater<>());sort(,,less<>())//两个函数在functional头文件中，greater从大到小排序，less从小到大排序。
```	
* string 之间 有 +=运算符（合并），但是没有 s = s + p;不能分开"+=";
* string 之间 没有 -=运算符
* string也有 push_back,pop_back运算符，估计vector有的string都有，因为string也相当于一个数组。
* npos函数：https://blog.csdn.net/guoqingshuang/article/details/80318476

* ** 关于printf输出字符串时乱码原因：https://www.cnblogs.com/cnhk19/p/15750051.html**
* 解决办法：.c_str();//字符串变量后添加





----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------

### 进制哈希
* BKDRHash:设定一个进制P，计算一个字符串的哈希值时，把每个字符串看作每个进制位上的一个数字，这个串转换为一个基于进制P的数，最后对M取余（一般假定M->unsigned long long），即得到该字符串的哈希值
* 即：进制转换，如：abc=》'a'*P^2 + 'b'*p^1 +'c'*p^0
* 模板题：给定N个字符传，第i个字符串长度Mi，字符串内包括数字和大小写字母，求N个字符串中共有多少个不同的字符串？
  ```c++
    #include<bits/stdc++.h>
	using namespace std;
	typedef unsigned long long ull;
	
	ull a[10010];
	string s;
	bool cmp(ull a, ull b)
	{
	    return a>b;
	}
	
	ull BKDRHash(string s)
	{
	    ull P = 131, H = 0;
	    int n = s.size();
	    for(int i = 0; i < n; i++)
	    {
	        H = H * P + s[i]-'a' + 1;
	    }
	    return H;//一个哈希函数值
	}
	
	int main()
	{
	    int n; 
	    cin>>n;
	    for(int i = 0; i < n; i++)
	    {
	        cin>>s;
	        a[i] = BKDRHash(s);  //存储每一个字符串的哈希值
	    }
	    
	    int ans = 0;
	    sort(a, a+n, cmp);
	    for(int i = 0; i < n; i++)
	    {
	        if(a[i] != a[i+1])
	        {
	            ans++;
	        }
	    }
	    cout<<ans;
	}
  ```
* Manacher算法求最长回文子串：
* 原理：
* ![image](https://github.com/Vajackye/Vajackye_Codespace/assets/121871885/bc4a7b5e-6fc8-4f9a-9042-bac166d71dd7)

* 模板题目：给出一个只由小写英文字符 a,b,c,…y,z组成的字符串 S ,求 S 中最长回文串的长度 。字符串长度为n
* ```c++
  #include<bits/stdc++.h>
	using namespace std;
	const int N = 11000002;
	int n, P[N << 1]; // p[i]为以s[i]为中心的回文半径，eg：10个字符，长度为5
	char a[N], s[N << 1]; //半径
	
	void change()  //添加分割符号，使得字串统一为奇数长字串
	{
	    n = strlen(a); // 长度
	    int k = 0; // 变革长度
	    s[k++] = '*'; s[k++] = '#'; //分隔符，最外层为"*","&",表示界限符号，防越界
	    for (int i = 0; i < n; i++)
	    {
	        s[k++] = a[i];
	        s[k++] = '#'; //每一个字符之间加分隔符
	    }
	    s[k++] = '&';
	    n = k; //更新长度
	
	
	}
	
	//Manacher算法
	void manacher()
	{
	    int R = 0, C;
	    for (int i = 1; i < n; i++)
	    {
	        if (i < R) P[i] = min(P[(C << 1) - i], P[C] + C - i); //合并两种情况，1.i的P[i]不超出R,2.i的P[i]超出R
	        else P[i] = 1; //从初始长度1个字符开始计算（1个字符半径为1）
	        while (s[i + P[i]] == s[i - P[i]]) P[i]++; //以i为半径，向左右拓展P[i](半径)个长度，回文则r++
	        if (P[i] + i > R) //新的最大R//即，不包括i在内
	        {
	            R = P[i] + i;
	            C = i;
	        }
	    }
	}
	
	int main()
	{
	    scanf("%s", a);
	    change();
	    manacher();
	    int ans = 1;
	    for (int i = 0; i < n; i++) ans = max(ans, P[i]);
	    printf("%d", ans-1);
	    return 0;
	}
  ```
  
